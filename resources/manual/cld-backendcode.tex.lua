---% language=uk
---
---\startcomponent cld-backendcode
---
---\environment cld-environment
---
---% derived from hybrid
---
---# Backend code
---
---\startsection [title={Introduction}]
---
---In *ConTeXt* we've always separated the backend code in so called driver files.
---This means that in the code related to typesetting only calls to the \API\ take
---place, and no backend specific code is to be used. Currently a *PDF* backend is
---supported as well as an \XML\ export. \footnote {This chapter is derived from an
---article on these matters. You can find nore information in `hybrid.pdf`.}
---
---Some *ConTeXt* users like to add their own *PDF* specific code to their styles or
---modules. However, such extensions can interfere with existing code, especially
---when resources are involved. Therefore the construction of *PDF* data structures
---and resources is rather controlled and has to be done via the official helper
---macros.
---
----------------------------------------------------------------


---
---\startsection [title={Structure}]
---
---A *PDF* file is a tree of indirect objects. Each object has a number and the file
---contains a table (or multiple tables) that relates these numbers to positions in
---a file (or position in a compressed object stream). That way a file can be viewed
---without reading all data: a viewer only loads what is needed.
---
---```
---1 0 obj <<
---    /Name (test) /Address 2 0 R
--->>
---2 0 obj [
---   (Main Street) (24) (postal code) (MyPlace)
---]
---```
---
---For the sake of the discussion we consider strings like `(test)` also to be
---objects. In the next table we list what we can encounter in a *PDF* file. There
---can be indirect objects in which case a reference is used (`2 0 R`) and
---direct ones.
---
---It all starts in the document's root object. From there we access the page tree
---and resources. Each page carries its own resource information which makes random
---access easier. A page has a page stream and there we find the to be rendered
---content as a mixture of (*Unicode*) strings and special drawing and rendering
---operators. Here we will not discuss them as they are mostly generated by the
---engine itself or dedicated subsystems like the \METAPOST\ converter. There we use
---literal or `\latelua` whatsits to inject code into the current stream.
---
----------------------------------------------------------------


---
---\startsection [title={Data types}]
---
---There are several datatypes in *PDF* and we support all of them one way or the
---other.
---
---\FL
--- \bf type  \bf form  \bf meaning 
---\TL
--- constant    `/...`  A symbol (prescribed string). 
--- string      `(...)`  A sequence of characters in pdfdoc encoding 
--- unicode     `<...>`  A sequence of characters in utf16 encoding 
--- number      `3.1415`  A number constant. 
--- boolean     `true/false`  A boolean constant. 
--- reference   `N 0 R`  A reference to an object 
--- dictionary  `<< ... >>`  A collection of key value pairs where the value itself is an (indirect) object. 
--- array       `[ ... ]`  A list of objects or references to objects. 
--- stream       A sequence of bytes either or not packaged with a dictionary that contains descriptive data. 
--- xform        A special kind of object containing an reusable blob of data, for example an image. 
---
---While writing additional backend code, we mostly create dictionaries.
---
---```
---<< /Name (test) /Address 2 0 R >>
---```
---
---In this case the indirect object can look like:
---
---```
---[ (Main Street) (24) (postal code) (MyPlace) ]
---```
---
---The *LuaTeX* manual mentions primitives like `\pdfobj`, `\pdfannot`,
---`\pdfcatalog`, etc. However, in \MKIV\ no such primitives are used. You can
---still use many of them but those that push data into document or page related
---resources are overloaded to do nothing at all.
---
---In the *Lua* backend code you will find function calls like:
---
---```
---local d = lpdf.dictionary {
---    Name    = lpdf.string("test"),
---    Address = lpdf.array {
---        "Main Street", "24", "postal code", "MyPlace",
---    }
---}
---```
---
---Equaly valid is:
---
---```
---local d = lpdf.dictionary()
---d.Name = "test"
---```
---
---Eventually the object will end up in the file using calls like:
---
---```
---local r = lpdf.immediateobject(tostring(d))
---```
---
---or using the wrapper (which permits tracing):
---
---```
---local r = lpdf.flushobject(d)
---```
---
---The object content will be serialized according to the formal specification so
---the proper `<< >>` etc. are added. If you want the content instead you can
---use a function call:
---
---```
---local dict = d()
---```
---
---An example of using references is:
---
---```
---local a = lpdf.array {
---    "Main Street", "24", "postal code", "MyPlace",
---}
---local d = lpdf.dictionary {
---    Name    = lpdf.string("test"),
---    Address = lpdf.reference(a),
---}
---local r = lpdf.flushobject(d)
---```
---
----------------------------------------------------------------


---
---We have the following creators. Their arguments are optional.
---
---\FL
--- \bf function  \bf optional parameter 
---\TL
--- `lpdf.null`         
---@field lpdf.number number # 
---@field lpdf.constant string # 
---@field lpdf.string string # 
---@field lpdf.unicode string # 
---@field lpdf.boolean boolean # 
--- `lpdf.array`        indexed table of objects 
--- `lpdf.dictionary`   hash with key/values 
---%NC `lpdf.stream`       indexed table of operators 
---@field lpdf.reference string # 
--- `lpdf.verbose`      indexed table of strings 
---
---\ShowLuaExampleString{tostring(lpdf.null())}
---\ShowLuaExampleString{tostring(lpdf.number(123))}
---\ShowLuaExampleString{tostring(lpdf.constant("whatever"))}
---\ShowLuaExampleString{tostring(lpdf.string("just a string"))}
---\ShowLuaExampleString{tostring(lpdf.unicode("just a string"))}
---\ShowLuaExampleString{tostring(lpdf.boolean(true))}
---\ShowLuaExampleString{tostring(lpdf.array { 1, lpdf.constant("c"), true, "str" })}
---\ShowLuaExampleString{tostring(lpdf.dictionary { a=1, b=lpdf.constant("c"), d=true, e="str" })}
---%ShowLuaExampleString{tostring(lpdf.stream("whatever"))}
---\ShowLuaExampleString{tostring(lpdf.reference(123))}
---\ShowLuaExampleString{tostring(lpdf.verbose("whatever"))}
---
----------------------------------------------------------------


---
---# Managing objects
---
---Flushing objects is done with:
---
---```
---lpdf.flushobject(obj)
---```
---
---Reserving object is or course possible and done with:
---
---```
---local r = lpdf.reserveobject()
---```
---
---Such an object is flushed with:
---
---```
---lpdf.flushobject(r,obj)
---```
---
---We also support named objects:
---
---```
---lpdf.reserveobject("myobject")
---
---lpdf.flushobject("myobject",obj)
---```
---
---A delayed object is created with:
---
---```
---local ref = pdf.delayedobject(data)
---```
---
---The data will be flushed later using the object number that is returned (`ref`). When you expect that many object with the same content are used, you can
---use:
---
---```
---local obj = lpdf.shareobject(data)
---local ref = lpdf.shareobjectreference(data)
---```
---
---This one flushes the object and returns the object number. Already defined
---objects are reused. In addition to this code driven optimization, some other
---optimization and reuse takes place but all that happens without user
---intervention. Only use this when it's really needed as it might consume more
---memory and needs more processing time.
---
---\startsection [title={Resources}]
---
---While *LuaTeX* itself will embed all resources related to regular typesetting,
---\MKIV\ has to take care of embedding those related to special tricks, like
---annotations, spot colors, layers, shades, transparencies, metadata, etc. Because
---third party modules (like tikz) also can add resources we provide some macros
---that makes sure that no interference takes place:
---
---```
---\pdfbackendsetcatalog       {key}{string}
---\pdfbackendsetinfo          {key}{string}
---\pdfbackendsetname          {key}{string}
---
---\pdfbackendsetpageattribute {key}{string}
---\pdfbackendsetpagesattribute{key}{string}
---\pdfbackendsetpageresource  {key}{string}
---
---\pdfbackendsetextgstate     {key}{pdfdata}
---\pdfbackendsetcolorspace    {key}{pdfdata}
---\pdfbackendsetpattern       {key}{pdfdata}
---\pdfbackendsetshade         {key}{pdfdata}
---```
---
---One is free to use the *Lua* interface instead, as there one has more
---possibilities but when code is shared with other macro packages the macro
---interface makes more sense. The names of the *Lua* functions are similar, like:
---
---```
---lpdf.addtoinfo(key,anything_valid_pdf)
---```
---
---Currently we expose a  bit more of the backend code than we like and
---future versions will have a more restricted access. The following
---function will stay public:
---
---```
---lpdf.addtopageresources  (key,value)
---lpdf.addtopageattributes (key,value)
---lpdf.addtopagesattributes(key,value)
---
---lpdf.adddocumentextgstate(key,value)
---lpdf.adddocumentcolorspac(key,value)
---lpdf.adddocumentpattern  (key,value)
---lpdf.adddocumentshade    (key,value)
---
---lpdf.addtocatalog        (key,value)
---lpdf.addtoinfo           (key,value)
---lpdf.addtonames          (key,value)
---```
---
----------------------------------------------------------------


---
---\startsection [title={Annotations}]
---
---You can use the *Lua* functions that relate to annotations etc. but normally you
---will use the regular *ConTeXt* user interface. You can look into some of the
---`lpdf-*` modules to see how special annotations can be dealt with.
---
----------------------------------------------------------------


---
---\startsection [title={Tracing}]
---
---There are several tracing options built in and some more will be added in due
---time:
---
---```
---\enabletrackers
---  [backend.finalizers,
---   backend.resources,
---   backend.objects,
---   backend.detail]
---```
---
---As with all trackers you can also pass them on the command line, for example:
---
---```
---context --trackers=backend.* yourfile
---```
---
---The reference related backend mechanisms have their own trackers. When you write
---code that generates *PDF*, it also helps to look in the *PDF* file so see if
---things are done right. In that case you need to disable compression:
---
---```
---\nopdfcompression
---```
---
----------------------------------------------------------------


---
---# Analyzing
---
---The `epdf` library that comes with *LuaTeX* offers a userdata interface to
---*PDF* files. On top of that *ConTeXt* provides a more *Lua*-ish access, using
---tables. You can open a *PDF* file with:
---
---```
---local mypdf = lpdf.epdf.load(filename)
---```
---
---When opening is successful, you have access to a couple of tables:
---
---```
--- `pages`          indexed 
--- `destinations`   hashed  
--- `javascripts`    hashed  
--- `widgets`        hashed  
--- `embeddedfiles`  hashed  
--- `layers`         indexed 
---```
---
---These provide efficient access to some data that otherwise would take a bit of
---code to deal with. Another top level table is the for *PDF* characteristic `Catalog`. Watch the capitalization: as with other native *PDF* data structures,
---keys are case sensitive and match the standard.
---
---Here is an example of usage:
---
---```
---local MyDocument = lpdf.epdf.load("somefile.pdf")
---
---context.starttext()
---
---  local pages    = MyDocument.pages
---  local nofpages = pages.n
---
---  context.starttabulate { "|c|c|c|" }
---
---    context.NC() context("page")
---    context.NC() context("width")
---    context.NC() context("height") context.NR()
---
---    for i=1, nofpages do
---      local page = pages[i]
---      local bbox = page.CropBox or page.MediaBox
---      context.NC() context(i)
---      context.NC() context(bbox[4]-bbox[2])
---      context.NC() context(bbox[3]-bbox[1]) context.NR()
---    end
---
---  context.stoptabulate()
---
---context.stoptext()
---```
---
----------------------------------------------------------------


---
---\stopchapter
---
---\stopcomponent
---